# Aggregate 와 Entity

1. 애그리거트는 깊이 연관된(아래에서 구체적인 조건을 설명함) 엔터티들의 집합이다.

2. 엔터티는 밸류와 같이 도메인 개념을 표현하는 모델이지만, 추가로 고유한 식별자가 있어 식별자로 동일성을 판단하게 되는 특징을 갖는 객체이다.

## Aggregate의 특징 및 구현 예제

1.  `애그리거트 루트` 혹은 `루트 엔터티`라고 하는 엔터티가 핵심 개념으로 존재하고, 그 핵심 개념에 부가적인 개념이 엔터티나 밸류로 붙는 형태를 갖는다. 

2. 예를 들어, `주문` 애그리거트의 경우, `Order`라는 애그리거트 루트에 `OrderLine`이라는 엔터티와 `Orderer`라는 밸류가 붙는 식이다. 이를 코드로 표현한다면 아래와 유사할 것이다:

    ```java
    // 주문 애그리거트의 애그리거트 루트(루트 엔터티)
    // Order도 엔터티이다. 다만, 애그리거트의 핵심 개념을 표현하므로, 루트 엔터티라고 하는 것이다.
    @Entity
    @Table(name = "purchase_order")
    public class Order {

        // 밸류
        @Embedded
        private Orderer orderer;

        // 엔터티 - 루트 엔터티는 아니지만, Order 엔터티와 깊이 연관되어 있다.
        @ElementCollection
        @CollectionTable(name = "order_line", joinColumns = @JoinColumn(name = "order_number"))
        @OrderColumn(name = "line_idx")
        private List<OrderLine> orderLines;
    }
    ```

3. 애그리거트 루트는 자신의 메소드를 통해 애그리거트의 일관성이 깨지지 않도록 강제하는 역할을 수행해야 한다. 애그리거트 루트에서 도메인 논리를 구현하여, 해당 도메인 논리를 수행하기 위해 어쩔 수 없이 애그리거트 루트에게 위임하게 되는 경우, 일관성을 강제하는 로직을 수행할 수 있게 된다.

    ```java
    public class Order {
        private int totalAmount;
        private List<orderLine> orderLines;
        //...
    }

    public class OrderLine {

        private int quantity;
        //...
    }
    ```

    위와 같이 주문 애그리거트가 구성된 경우, `OrderLine`의 `quantity`가 변경된 경우, `Order`의 `totalAmount`도 변경되어야 한다. 그렇지 않으면 `주문 총 금액은 개별 상품의 주문 개수 X 가격의 합이다.`라는 도메인 규칙을 어기고 데이터 일관성이 깨지게 된다.

4. (4)를 더 보강하기 위해, 도메인 모델에서 `setter`를 `public`으로 작성하지 않는 것과 밸류를 불변으로 작성하는 것이 요구된다. 애그리거트 루트에서 `getter`를 통해 내부 엔터티나 밸류에 접근해 `setter`를 호출하는 경우, 애그리거트가 일관성이 깨지지 않도록 강제할 수 없게 되기 때문이다.

5. `[dddstart]` 애그리거트는 일관성(영속성)의 단위임과 동시에 데이터 일관성을 유지해야 하므로, 같이 저장되어 같이 갱신되고 같이 제거되는 것이 옳다. 그렇기 때문에 루트 엔터티만 `Repository`가 존재하게 된다.

## 왜 필요할까?

1. `[dddstart]` 애그리거트와 같은 상위 수준 개념을 이용하여 전체 도메인을 정리한다면 하위 도메인들의 관계를 이해하는 데 도움이 된다. 만약 하위 도메인간의 관계를 파악하는 일이 어려운 경우, 코드 변경 및 확장에 치명적이기 때문에 중요하다.

2. 애그리거트가 타 애그리거트를 참조할 때는 항상 루트 엔터티만 참조해야 하므로, 모듈화가 더 잘 적용된다고 할 수 있다.

## 애그리거트를 발견하는 방법

1. `[dddstart]` 도메인 규칙에 따라 함께 생성성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.

    ex: Product가 Review를 소유하지만, Product와 Review는 같은 애그리거트가 아니다.

2. `[dddstart]` 도메인에 대한 경험이 생기고 도메인 규칙을 제대로 이해할수록 실제 애그리거트의 크기는 줄어들게 된다고 한다.

3. `[dddstart]` 다수의 애그리거트가 한 개의 엔터티 객체만 갖는 경우가 많으며 두 개 이상의 엔터티로 구성되는 애그리거트는 드물게 존재한다고 한다.